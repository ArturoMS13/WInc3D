#!/usr/bin/env python
"""
Script that extracts the mean velocity from Incompact3D
Author : Georgios (Yorgos) Deskos 2017
"""
import math
import argparse
import csv
import f90nml
import numpy as np
from scipy import interpolate
import matplotlib.pyplot as plt

# ====================================
# Parser Arguments
# ====================================
parser = argparse.ArgumentParser(description="Script to extract wake statistics from *.dat files")
parser.add_argument("-v","--verbose",action="store_true",help="Print location")
parser.add_argument("-p","--plot",action="store_true",help="Plots the wake profiles")
parser.add_argument("-w","--write",action="store_true",help="Write results in a .csv file")
parser.add_argument("PATH", type=str, help="path to where the umean, vmean etc. files are (should end with a / )")
parser.add_argument("FILENAME", type=str, help="Filename, should end with .pprc")
parser.add_argument("OUTPUT", type=str, help="OUTPUT FOLDER")

args = parser.parse_args()
path = args.PATH
name = args.FILENAME
output = args.OUTPUT

# Read the fortran nml (NAMELIST)
nml=f90nml.read(name)

with open(name) as nml_file:
    nml = f90nml.read(nml_file)

nx=nml['PostProcess']['nx']
ny=nml['PostProcess']['ny']
nz=nml['PostProcess']['nz']
xlx=nml['PostProcess']['xlx']
yly=nml['PostProcess']['yly']
zlz=nml['PostProcess']['zlz']

# This is not valid for always
nxd=nx-1
nyd=ny-1
nzd=nz-1

dx=xlx/nxd
dy=yly/nyd
dz=zlz/nzd


# UMEAN - Average velocities for u, v and w
ufile=open(path+"umean.dat","rb")
vfile=open(path+"vmean.dat","rb")
wfile=open(path+"wmean.dat","rb")
# uu - Average of the squares of the velocities u, v and w
# This is not the <u'u'> etc.
# To compute the <u'u'> we need to do <u'u'>=<uu> - <u><u>
# and similarly for the other quantities
uufile=open(path+"uumean.dat","rb")
vvfile=open(path+"vvmean.dat","rb")
wwfile=open(path+"wwmean.dat","rb")
uvfile=open(path+"uvmean.dat","rb")
uwfile=open(path+"uwmean.dat","rb")
vwfile=open(path+"vwmean.dat","rb")
# vu, wu, wv are ommited due to symmetry

# Reading the binary files into numpy vectors
umean=np.fromfile(ufile,dtype=np.float64)
vmean=np.fromfile(vfile,dtype=np.float64)
wmean=np.fromfile(wfile,dtype=np.float64)
uumean=np.fromfile(uufile,dtype=np.float64)
vvmean=np.fromfile(vvfile,dtype=np.float64)
wwmean=np.fromfile(wwfile,dtype=np.float64)
uvmean=np.fromfile(uvfile,dtype=np.float64)
vwmean=np.fromfile(vwfile,dtype=np.float64)
vwmean=np.fromfile(vwfile,dtype=np.float64)


# Initialising the 3D arrays to map the velocities etc.
x=np.zeros((nx,ny,nz))
y=np.zeros((nx,ny,nz))
z=np.zeros((nx,ny,nz))
uav=np.zeros((nx,ny,nz))
vav=np.zeros((nx,ny,nz))
wav=np.zeros((nx,ny,nz))
upup=np.zeros((nx,ny,nz))
vpvp=np.zeros((nx,ny,nz))
wpwp=np.zeros((nx,ny,nz))


Nsteps=nml['PostProcess']['NSteps']

# Compute average quantities
if args.verbose:
    print('Computing the average quantities \n')
for i in range(0,nx):
    for j in range(0,ny):
        for k in range(0,nz):
            x[i,j,k]=i*dx
            y[i,j,k]=j*dy
            z[i,j,k]=k*dz
            uav[i,j,k]=umean[i+nx*(j+ny*k)]/Nsteps
            vav[i,j,k]=vmean[i+nx*(j+ny*k)]/Nsteps
            wav[i,j,k]=wmean[i+nx*(j+ny*k)]/Nsteps
            upup[i,j,k]=uumean[i+nx*(j+ny*k)]/Nsteps-uav[i,j,k]**2
            vpvp[i,j,k]=vvmean[i+nx*(j+ny*k)]/Nsteps-vav[i,j,k]**2
            wpwp[i,j,k]=wwmean[i+nx*(j+ny*k)]/Nsteps-wav[i,j,k]**2



D=nml['PostProcess']['D']
Uinf=nml['PostProcess']['Uinf']
xref=nml['PostProcess']['xref']
TSR=nml['PostProcess']['TSR']
xloc=nml['PostProcess']['xloc']
yloc=nml['PostProcess']['yloc']
zloc=nml['PostProcess']['zloc']
R=D/2.0


for i in range(len(xloc)):
    print('Computing statistics at location ' + str(float(xloc[i]))+'...\n')
    
    ixloc=np.where(abs(x[:,0,0]-xloc[i])==abs(x[:,0,0]-xloc[i]).min())[0]
    jxloc=np.where(abs(y[0,:,0]-yloc[i])==abs(y[0,:,0]-yloc[i]).min())[0]
  
    print 'found indices ', ixloc[0], jxloc[0]
    if args.write:     
        with open(output+'TSR_'+str(int(TSR))+'_XD_'+str(int((xloc[i]-xref)/D))+'_Horizontal.dat','w') as fout:
            fout.write('# y/R 1-u/Uref u/U k/Uref^2 up^2/Uref^2 vpvp/Uref^2 wpwp/Uref^2\n')
            for iwake in range(nz):
                rR=float(-zlz/(2.0*R)+z[ixloc[0],jxloc[0],iwake]/R)
                uUDef=float(1.-uav[ixloc[0],jxloc[0],iwake]/Uinf)
                uU=float(uav[ixloc[0],jxloc[0],iwake]/Uinf)
                TKEU2=float(0.5*(upup[ixloc[0],jxloc[0],iwake]+vpvp[ixloc[0],jxloc[0],iwake]+wpwp[ixloc[0],jxloc[0],iwake])/Uinf**2)
                upupU2=float(upup[ixloc[0],jxloc[0],iwake]/Uinf**2)
                vpvpU2=float(vpvp[ixloc[0],jxloc[0],iwake]/Uinf**2)
                wpwpU2=float(wpwp[ixloc[0],jxloc[0],iwake]/Uinf**2)
                fout.write(str(rR)+' '+str(uUDef)+' '+str(uU) +' '+str(TKEU2)+' '+str(upupU2)+' '+str(vpvpU2)+' '+str(wpwpU2)+'\n')
            
    if args.plot:    
        plt.figure(1)
        plt.plot(-zlz/(2.0*R)+z[ixloc[0],jxloc[0],:].reshape(nz,1)/R,uav[ixloc[0],jxloc[0],:].reshape(nz,1)/Uinf,'k')
        plt.show()

        plt.figure(2)
        plt.plot(-zlz/(2.0*R)+z[ixloc[0],jxloc[0],:].reshape(nz,1)/R,upup[ixloc[0],jxloc[0],:].reshape(nz,1)/Uinf**2,'k')
        plt.show()

exit()

plt.figure()
plt.pcolormesh(x[:,49,:],z[:,49,:],upup[:,49,:],cmap=plt.get_cmap('jet'))
plt.colorbar()
plt.xlim(0,11.15)
plt.ylim(0,2.7)
plt.axis('equal')
plt.show()
